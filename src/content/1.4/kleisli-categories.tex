% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{지}{금까지} 어떻게 타입과 순수 함수를 \trCategory로 모델링할 수 있는 지 살펴보았다.
또 \trCategory에서 순수하지 않은 함수 혹은 \trSideEffect를 모델링하는 방법이 존재한다는 것도 이야기했다.
이런 예시를 하나 살펴보자. 실행 과정을 추적하고 로그를 남기는 함수의 경우, 명령형 언어에서는 어떤 전역 상태를 조작하는 방식으로 구현될 것이다.

\begin{snip}{cpp}
string logger;

bool negate(bool b) {
    logger += "Not so! ";
    return !b;
}
\end{snip}
이 함수는 메모이제이션할 경우 로그가 발생하지 않게 되기 때문에 순수 함수가 아니다. 이 함수는 \newterm{\trSideEffect}를 가지고 있다.

현대 프로그래밍에서는 동시성(Concurrency)이 가진 복잡함 때문에 최대한 전역 상태를 조작하지 않으려고 노력한다. 이런 코드를 라이브러리에 집어넣으면 안 된다.

다행히도, 이 함수를 순수하게 만들 수 있는 방법이 있다. 단순히 로그를 명시적으로 전달받고, 전달해주면 된다. 문자열 인자를 추가하고, 원래 함수의 출력과 갱신된 로그를 묶어서 리턴하게 바꿔보자.

\begin{snip}{cpp}
pair<bool, string> negate(bool b, string logger) {
    return make_pair(!b, logger + "Not so! ");
}
\end{snip}
이 함수는 순수하고, \trSideEffect가 없고, 동일한 인자로 호출될 경우 항상 동일한 페어를 리턴한다. 따라서 이 함수는 필요하다면 메모이제이션될 수 있다.
하지만, 로그가 가진 누적된다(cumulative)는 성질 때문에 이 함수를 메모이제이션하려면 함수를 호출할 때 생길 수 있는 가능한 모든 로그 히스토리들을 다 메모이제이션해야만 할 것이다.
따라서,

\begin{snip}{cpp}
negate(true, "It was the best of times. ");
\end{snip}
같은 호출과,

\begin{snip}{cpp}
negate(true, "It was the worst of times. ");
\end{snip}
같은 호출, 그 외의 다른 모든 인자들에 대해 모두 따로따로 메모이제이션해야 한다.

또, 이는 라이브러리 함수로서 그다지 좋은 인터페이스는 아니다. 함수를 호출하는 쪽에서 리턴값의 문자열(로그)은 자유롭게 무시할 수 있기 때문에 이는 그다지 큰 부담이 아니다.
하지만 로그를 함수의 입력으로 넘겨주는 걸 강제하는데 이게 불편할 수 있다.

같은 동작을 좀 덜 거슬리게 만들 수 있는 방법은 없을까? 서로 다른 고려사항을 분리하는 방법은 없을까? 이 단순한 예제에서, \code{negate} 함수의 주 목적은 불리언 값을 반대로 뒤집어주는 것이다.
로그는 보조적인 역할이다. 로그에 추가되는 메시지는 함수에 의해 정해지지만, 그 메시지들을 모아서 하나의 연속된 로그로 만드는 것은 그와는 별개의 문제다.
함수가 문자열을 생성하길 바라지만, 로그를 생성하는 작업에 대한 부담은 덜어내고 싶다. 따라서, 타협하면 이런 해결책이 나온다.

\begin{snip}{cpp}
pair<bool, string> negate(bool b) {
    return make_pair(!b, "Not so! ");
}
\end{snip}
로그를 모으는 작업을 함수 호출\emph{사이에} 해주자는 발상이다.

이 작업이 어떻게 이뤄질 수 있을지 살펴보기 위해 예제를 좀 더 현실적인 예제로 바꿔보자. 주어진 문자열에서 소문자를 전부 대문자로 바꾸는 함수가 있다.

\begin{snip}{cpp}
string toUpper(string s) {
    string result;
    int (*toupperp)(int) = &toupper; // toupper is overloaded
    transform(begin(s), end(s), back_inserter(result), toupperp);
    return result;
}
\end{snip}
그리고, 문자열을 공백을 기준으로 여러 개의 문자열로 나누는 함수가 있다.

\begin{snip}{cpp}
vector<string> toWords(string s) {
    return words(s);
}
\end{snip}
실제 작업은 \code{words}라는 보조 함수에서 이루어진다.

\begin{snip}{cpp}
vector<string> words(string s) {
    vector<string> result{""};
    for (auto i = begin(s); i != end(s); ++i)
    {
        if (isspace(*i))
            result.push_back(""); 
        else
            result.back() += *i;
    }
    return result;
}
\end{snip}
\code{toUpper} 함수와 \code{toWords} 함수가 그 리턴값에 덧붙여 메시지 문자열을 반환하게 바꿔보자.

\begin{figure}[H]
\centering
\includegraphics[width=0.3\textwidth]{images/piggyback.jpg}
\end{figure}
\noindent
임의 타입의 요소 및 문자열 요소로 구성된 쌍(pair)을 캡슐화하는 \code{Writer} 템플릿을 정의함으로서 일반화된 방식으로 함수의 리턴값을 ``\trEmbellish(embellish)해'' 볼 것이다.

\begin{snip}{cpp}
template<class A>
using Writer = pair<A, string>;
\end{snip}
그리고 이것이 \trEmbellish된 함수다.

\begin{snip}{cpp}
Writer<string> toUpper(string s) {
    string result;
    int (*toupperp)(int) = &toupper;
    transform(begin(s), end(s), back_inserter(result), toupperp);
    return make_pair(result, "toUpper "); 
}

Writer<vector<string>> toWords(string s) { 
    return make_pair(words(s), "toWords ");
}
\end{snip}
이제 이 함수들을 합성한 또다른 \trEmbellish된 함수를 만들어보자. 이 함수는 문자열의 소문자를 모두 대문자로 바꾸고, 이 문자열을 공백을 기준으로 분할한다. 그리고 그 과정에 대한 로그를 생성한다.
아마 아래와 같은 방식으로 구현할 수 있을 것이다.

\begin{snip}{cpp}
Writer<vector<string>> process(string s) {
    auto p1 = toUpper(s);
    auto p2 = toWords(p1.first);
    return make_pair(p2.first, p1.second + p2.second);
}
\end{snip}
이제 원래의 목표를 달성했다. 로그를 모으는 것은 더 이상 개별 함수의 관심사가 아니다. 각 함수는 메시지를 생성하고, 함수 외부에서 그 메시지를 연결해서 더 큰 로그를 만들어낸다.

이제 프로그램을 전부 이 방식으로 작성했다고 상상해보자. 이 프로그램은 반복되고, 에러에 취약한 코드로 가득찬 끔찍한 형태일 것이다. 하지만 우리는 프로그래머다.
이런 반복되는 코드를 어떻게 처리해야하는 지 알고 있다. 답은 바로 추상화다!
% mill abstraction이 무슨 의미일까요?? 찾아봐도 영.. 일단 대충 제가 받아들인 뜻에 맞춰서 번역했어요 %
하지만 이건 늘상하던 그런 추상화가 아니다.우리는 \newterm{함수\trComposition} 자체를 추상화할 것이다.
그러나 \trComposition은 \trCategoryTheory의 정수 그 자체이기 때문에, 코드를 짜기 전에 먼저 문제를 \trCategory의 시점에서 분석해보자.

\section{Writer \trCategory}

몇 가지 추가적인 기능을 더하기 위해 함수의 리턴 타입을 \trEmbellish하는 발상은 꽤나 유익하다는 것을 살펴보았다.
이런 예시를 더 많이 알아보자. 타입과 함수에 대한 일반적인 \trCategory가 그 시작점이다. 타입은 \trObject로 내버려둘 거지만, \trMorphism은 \trEmbellish된 함수로 재정의할 것이다.

예를 들어, \cide{int} 를 받아서 \code{bool}을 반환하는 \code{isEven} 함수를 \trEmbellish한다고 생각해보자. 이 함수를 \trEmbellish된 함수로 표현되는 \trMorphism으로 바꿀 것이다.
중요한 점은 \trEmbellish된 함수는 페어(pair)를 리턴함에도 불구하고, 이 \trMorphism은 여전히 \code{int} 와 \code{bool} \trObject 간의 \trArrow로 볼 수 있다는 것이다. 

\begin{snip}{cpp}
pair<bool, string> isEven(int n) {
    return make_pair(n % 2 == 0, "isEven ");
}
\end{snip}
\trCategory의 규칙으로 인해, 이 \trMorphism을 \code{bool} \trObject에서 시작하는 다른 \trMorphism과 \trComposition할 수 있어야만 한다.
특히, 이 함수를 앞서 작성한 \code{negate}와도 합성이 가능해야 할 것이다.

\begin{snip}{cpp}
pair<bool, string> negate(bool b) {
    return make_pair(!b, "Not so! ");
}
\end{snip}
이 두 \trMorphism\를 일반적인 함수를 합성하듯 합성할 수 없다는 것은 명확하다. 입출력이 일치하지 않기 때문이다. 이들의 \trComposition\은 이런 형태가 되어야 한다.

\begin{snip}{cpp}
pair<bool, string> isOdd(int n) {
    pair<bool, string> p1 = isEven(n);
    pair<bool, string> p2 = negate(p1.first);
    return make_pair(p2.first, p1.second + p2.second);
}
\end{snip}
따라서 우리가 만들어낸 이 새로운 \trCategory에서 두 \trMorphism의 \trComposition은 아래와 같이 진행되어야 한다. 

\begin{enumerate}
\tightlist
\item
  첫 번째 \trMorphism에 대응하는 \trEmbellish된 함수를 실행한다.
\item
  실행 결과값 쌍에서 첫번째 요소를 추출한다. 이 값을 두 번째 \trMorphism에 대응하는 \trEmbellish된 함수에 전달한다.
\item
  첫 번째 실행 결과의 두 번째 요소(문자열)과 두 번째 실행 결과의 두번째 요소(문자열)을 연결한다.
\item
  최종 결과값을 첫번째 요소로, 연결한 문자열을 두 번째 요소로 하는 쌍을 리턴한다.
\end{enumerate}

이 \trComposition을 C++에서 \trHigherOrderFunction으로 추상화하려면, 이 \trCategory의 세 \trObject에 대응하는 세 개의 타입 \trParameter를 사용하는 템플릿을 써야한다.
이 함수는 우리의 규칙에 따라서 \trComposition 할 수 있는 두 개의 \trEmbellish된 함수를 받아서 세 번째 \trEmbellish된 함수를 반환한다.

\begin{snip}{cpp}
template<class A, class B, class C>
function<Writer<C>(A)> compose(function<Writer<B>(A)> m1,
                               function<Writer<C>(B)> m2)
{
    return [m1, m2](A x) {
        auto p1 = m1(x);
        auto p2 = m2(p1.first);
        return make_pair(p2.first, p1.second + p2.second); 
    };
}
\end{snip}
이제 이 새로운 템플릿을 이용해 앞서 예제로 다룬 \code{toUpper}와 \code{toWords}의 \trComposition을 구현할 수 있다.

\begin{snip}{cpp}
Writer<vector<string>> process(string s) { 
    return compose<string, string, vector<string>>(toUpper, toWords)(s);
}
\end{snip}
여전히 \code{compose} 템플릿에 타입을 넘겨줘야 하는 귀찮은 부분이 남아 있다.
이 문제는 일반화된 람다 함수(generalized lambda function)과 리턴 타입 추론을 지원하는 C++ 14 컴파일러를 사용하면 피할 수 있다(아래 코드는 Eric niebler가 작성했다).

\begin{snip}{cpp}
auto const compose = [](auto m1, auto m2) { 
    return [m1, m2](auto x) { 
        auto p1 = m1(x);
        auto p2 = m2(p1.first);
        return make_pair(p2.first, p1.second + p2.second);
    };
};
\end{snip}
이 새로운 정의 하에서, \code{process}의 구현은 다음과 같이 단순화할 수 있다.

\begin{snip}{cpp}
Writer<vector<string>> process(string s) {
    return compose(toUpper, toWords)(s);
}
\end{snip}
하지만 아직 끝난게 아니다. 이 새로운 \trCategory에서의 \trComposition은 정의했지만, 그렇다면 뭐가 \trIdentityMorphism인걸까?
이는 일반적인 \trIdentityFunction이 아니다. 이 \trCategory는 타입 A에서 타입 A로 돌아오는 \trMorphism을 가져야 한다. 그러니까, 아래와 같은 형태의 \trEmbellish된 함수가 있어야 한다.

\begin{snip}{cpp}
Writer<A> identity(A);
\end{snip}
이는 \trComposition에 대한 \trUnit처럼 동작해야 한다.
앞서 정의한 \trComposition의 정의를 잘 살펴보면, \trIdentityMorphism은 그 \trArgument를 변화없이 그대로 넘겨주되, 로그에는 텅 빈 문자열을 추가하는 것이 \trIdentityMorphism이 된다는 것을 알 수 있을 것이다.

\begin{snip}{cpp}
template<class A> Writer<A> identity(A x) {
    return make_pair(x, "");
}
\end{snip}
이렇게 정의된 \trCategory가 정말로 적법한 \trCategory임은 쉽게 납득할 수 있을 것이다.
특히, 이 \trCategory에서의 \trCompositon은 결합 법칙이 성립함이 자명하다.
결과 값 쌍에서의 첫번째 요소만 놓고 보면, 이는 일반적인 함수 합성과 동일하므로 결합 법칙이 성립한다. 두번째 요소의 경우 문자열을 연결하는 연산인데, 이 연산 역시도 결합 법칙이 성립한다.

영악한 독자라면 이러한 구성을 문자열 \trMonoid 뿐 아니라 임의의 \trMonoid로 일반화할 수 있음을 깨달았을 지도 모른다.
\code{compose} 내에서 \code{mappend}를 쓰고, \code{identity} 내에서 \code{mempty}를 쓸 수 있다(\code{+}와 \code{""} 대신에).
로깅을 문자열에만 한정 지을 이유는 어디에도 없다. 좋은 라이브러리 작성자는 라이브러리가 동작하게 만들기 위한 가장 기본적인 제한 조건이 무엇인지 판별할 수 있어야 한다.
여기서 로깅 라이브러리의 유일한 제약 조건은 로그가 \trMonoid의 성질을 가질 것 밖에 없다. % 이거 어떻게 번역하는게 좋을까요.. monoidal이 결합법칙 성립 + 항등원 존재하는 이항 연산 뜻하는 건데..

\section{하스켈에서의 Writer}

하스켈에서는 똑같은 함수가 좀 더 간결하고, 컴파일러로부터 더 많은 도움을 받을 수 있다. \code{Writer} 타입을 정의하는 것부터 시작해보자.

\src{snippet01}
여기선 C++에서 \code{typedef}(혹은 \code{using})과 동일한 기능을 하는 타입 별칭만을 정의했다.
\code{Writer} 타입은 타입변수 \code{a}를 인자로 받으며, \code{a}와 \code{String}의 쌍과 동일하다.
값의 쌍을 위한 구문은 굉장히 간소하다. 소괄호로 감싼 두 요소 및 그 요소들을 구분하는 콤마(,)만을 사용한다.

앞서 다룬 \trMorphism은 임의 타입을 받아 \code{Writer} 타입을 반환하는 함수가 된다.

\src{snippet02}
\trComposition은 때때로 ``물고기(fish)''로 불리는 재미있는 중위 연산자로 선언할 수 있다.

\src{snippet03}
이 함수는 두 개의 함수를 \trArgument로 받아 새로운 함수를 리턴한다.
첫번째 \trArgument의 타입은 \code{(a -> Writer b)}이고, 두번째 \trArgument의 타입은 \code{(b -> Writer c)}이고, 리턴값의 타입은 \code{(a -> Writer c)}이다.

그리고 이것이 이 중위 연산자의 정의다. 두 \trArgument \code{m1} 과 \code{m2}가 물고기 기호의 양쪽에 나타난다.

\src{snippet04}
결과값은 \code{x}라는 하나의 \trArgument를 받는 람다 함수가 된다. 람다 함수는 백슬래쉬(\\)를 이용해 작성한다. 백슬래시를 그리스 문자 λ(람다)에서 한쪽 다리를 자른 것처럼 생각하면 된다.

\code{let} \trExpression은 보조 변수를 선언할 수 있게 해준다.
여기서는 \code{m1} 호출의 결과값을 \code{(y, s1)} 변수 쌍으로 패턴 매칭한다.
그리고 \code{m2}에 \code{y}를 넘겨 호출한 결과는 \code{(z, s2)}로 매칭된다.

C++에서 주로 접근자를 이용하는 것과 달리 하스켈에서는 변수 쌍에 패턴 매칭을 사용하는 것이 일반적이다. 그 외에는 두 구현이 동일하다는 것이 굉장히 명확하다.

\code{let} 표현식의 결과값은 그 표현식의 \code{in} 절에 명시한다. 여기서는 첫번째 요소가 \code{z}이고 두번째 요소가 두 문자열을 이은 결과인 \code{s1++s2}인 변수 쌍이다.

\trIdentityMorphism 역시도 정의해보자. 이걸 \code{return}이라고 부를 것인데, 왜 이런 이름으로 부르는 지는 나중에 명확해질 것이다.

\src{snippet05}
마무리로, 하스켈 버전의 \trEmbellish된 \code{upCase}, \code{toWords} 함수를 작성해보자.

\src{snippet06}
\code{map} 함수는 C++의 \code{transform}에 대응한다. 이 함수는 문자열 \code{s}의 각 문자에 대해 \code{toUpper}를 적용한다.
보조 함수 \code{words}는 표준 라이브러리 Prelude에 정의되어 있다.

마지막으로, 두 함수의 합성은 처음 이야기한 물고기 연산자의 도움을 받아 성사된다.

\src{snippet07}

\section{\trKleisli \trCategory}

이 \trCategory를 내가 즉석에서 발명해낸 것이라고 생각하진 않을 것이다.
이 \trCategory는 \trMonad에 기반한 \trCategory인 \trKleisli\trCategory의 예시중 하나다.
우린 아직 \trMonad에 대해 이야기할 준비가 되지 않았지만, \trMonad가 무슨 일을 할 수 있는지 살짝 맛만이라도 볼 수 있게 해주고 싶었다.
우리의 제한된 목적을 위해, \trKleisli\trCategory는 그 기저에 깔린 프로그래밍 언어의 타입을 \trObject로 갖는다.
타입 $A$로부터 타입 $B$로의 \trMorphism은 타입 $A$로 부터 특정한 \trEmbellish를 $B$ 타입에 적용한 타입으로의 함수다. 
각각의 \trKleisli\trCategory는 이런 \trMorphism을 \trComposition하기 위한 고유의 방법을 이 \trComposition의 \trIdentityMorphism과 함께 정의한다.
(나중에 우리는 모호한 ``\trEmbellish'' 라는 용어가 \trCategory에서 \trEndofunctor의 개념과 동일하다는 것을 알게 될 것이다.)

The particular monad that I used as the basis of the category in this
post is called the \newterm{writer monad} and it's used for logging or
tracing the execution of functions. It's also an example of a more
general mechanism for embedding effects in pure computations. You've
seen previously that we could model programming-language types and
functions in the category of sets (disregarding bottoms, as usual). Here
we have extended this model to a slightly different category, a category
where morphisms are represented by embellished functions, and their
composition does more than just pass the output of one function to the
input of another. We have one more degree of freedom to play with: the
composition itself. It turns out that this is exactly the degree of
freedom which makes it possible to give simple denotational semantics to
programs that in imperative languages are traditionally implemented
using side effects.

\section{Challenge}

A function that is not defined for all possible values of its argument
is called a partial function. It's not really a function in the
mathematical sense, so it doesn't fit the standard categorical mold. It
can, however, be represented by a function that returns an embellished
type \code{optional}:

\begin{snip}{cpp}
template<class A> class optional {
    bool _isValid;
    A _value;
public: 
    optional()    : _isValid(false) {}
    optional(A v) : _isValid(true), _value(v) {}
    bool isValid() const { return _isValid; }
    A value() const { return _value; }
};
\end{snip}
For example, here's the implementation of the embellished function
\code{safe\_root}:

\begin{snip}{cpp}
optional<double> safe_root(double x) {
    if (x >= 0) return optional<double>{sqrt(x)}; 
    else return optional<double>{};
}
\end{snip}
Here's the challenge:

\begin{enumerate}
\tightlist
\item
  Construct the Kleisli category for partial functions (define
  composition and identity).
\item
  Implement the embellished function \code{safe\_reciprocal} that
  returns a valid reciprocal of its argument, if it's different from
  zero.
\item
  Compose the functions \code{safe\_root} and \code{safe\_reciprocal} to implement
  \code{safe\_root\_reciprocal} that calculates \code{sqrt(1/x)}
  whenever possible.
\end{enumerate}
