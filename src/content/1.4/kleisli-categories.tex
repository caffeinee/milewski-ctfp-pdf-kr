% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{지}{금까지} 어떻게 타입과 순수 함수를 \trCategory로 모델링할 수 있는 지 살펴보았다.
또 \trCategory에서 순수하지 않은 함수 혹은 \trSideEffect를 모델링하는 방법이 존재한다는 것도 이야기했다.
이런 예시를 하나 살펴보자. 실행 과정을 추적하고 로그를 남기는 함수의 경우, 명령형 언어에서는 어떤 전역 상태를 조작하는 방식으로 구현될 것이다.

\begin{snip}{cpp}
string logger;

bool negate(bool b) {
    logger += "Not so! ";
    return !b;
}
\end{snip}
이 함수는 메모이제이션할 경우 로그가 발생하지 않게 되기 때문에 순수 함수가 아니다. 이 함수는 \newterm{\trSideEffect}를 가지고 있다.

현대 프로그래밍에서는 동시성(Concurrency)이 가진 복잡함 때문에 최대한 전역 상태를 조작하지 않으려고 노력한다. 이런 코드를 라이브러리에 집어넣으면 안 된다.

다행히도, 이 함수를 순수하게 만들 수 있는 방법이 있다. 단순히 로그를 명시적으로 전달받고, 전달해주면 된다. 문자열 인자를 추가하고, 원래 함수의 출력과 갱신된 로그를 묶어서 리턴하게 바꿔보자.

\begin{snip}{cpp}
pair<bool, string> negate(bool b, string logger) {
    return make_pair(!b, logger + "Not so! ");
}
\end{snip}
이 함수는 순수하고, \trSideEffect가 없고, 동일한 인자로 호출될 경우 항상 동일한 페어를 리턴한다. 따라서 이 함수는 필요하다면 메모이제이션될 수 있다.
하지만, 로그가 가진 누적된다(cumulative)는 성질 때문에 이 함수를 메모이제이션하려면 함수를 호출할 때 생길 수 있는 가능한 모든 로그 히스토리들을 다 메모이제이션해야만 할 것이다.
따라서,

\begin{snip}{cpp}
negate(true, "It was the best of times. ");
\end{snip}
같은 호출과,

\begin{snip}{cpp}
negate(true, "It was the worst of times. ");
\end{snip}
같은 호출, 그 외의 다른 모든 인자들에 대해 모두 따로따로 메모이제이션해야 한다.

또, 이는 라이브러리 함수로서 그다지 좋은 인터페이스는 아니다. 함수를 호출하는 쪽에서 리턴값의 문자열(로그)은 자유롭게 무시할 수 있기 때문에 이는 그다지 큰 부담이 아니다.
하지만 로그를 함수의 입력으로 넘겨주는 걸 강제하는데 이게 불편할 수 있다.

같은 동작을 좀 덜 거슬리게 만들 수 있는 방법은 없을까? 서로 다른 고려사항을 분리하는 방법은 없을까? 이 단순한 예제에서, \code{negate} 함수의 주 목적은 불리언 값을 반대로 뒤집어주는 것이다.
로그는 보조적인 역할이다. 로그에 추가되는 메시지는 함수에 의해 정해지지만, 그 메시지들을 모아서 하나의 연속된 로그로 만드는 것은 그와는 별개의 문제다.
함수가 문자열을 생성하길 바라지만, 로그를 생성하는 작업에 대한 부담은 덜어내고 싶다. 따라서, 타협하면 이런 해결책이 나온다.

\begin{snip}{cpp}
pair<bool, string> negate(bool b) {
    return make_pair(!b, "Not so! ");
}
\end{snip}
로그를 모으는 작업을 함수 호출\emph{사이에} 해주자는 발상이다.

이 작업이 어떻게 이뤄질 수 있을지 살펴보기 위해 예제를 좀 더 현실적인 예제로 바꿔보자. 주어진 문자열에서 소문자를 전부 대문자로 바꾸는 함수가 있다.

\begin{snip}{cpp}
string toUpper(string s) {
    string result;
    int (*toupperp)(int) = &toupper; // toupper is overloaded
    transform(begin(s), end(s), back_inserter(result), toupperp);
    return result;
}
\end{snip}
그리고, 문자열을 공백을 기준으로 여러 개의 문자열로 나누는 함수가 있다.

\begin{snip}{cpp}
vector<string> toWords(string s) {
    return words(s);
}
\end{snip}
실제 작업은 \code{words}라는 보조 함수에서 이루어진다.

\begin{snip}{cpp}
vector<string> words(string s) {
    vector<string> result{""};
    for (auto i = begin(s); i != end(s); ++i)
    {
        if (isspace(*i))
            result.push_back(""); 
        else
            result.back() += *i;
    }
    return result;
}
\end{snip}
\code{toUpper} 함수와 \code{toWords} 함수가 그 리턴값에 덧붙여 메시지 문자열을 반환하게 바꿔보자.

\begin{figure}[H]
\centering
\includegraphics[width=0.3\textwidth]{images/piggyback.jpg}
\end{figure}
\noindent
임의 타입의 요소 및 문자열 요소로 구성된 쌍(pair)을 캡슐화하는 \code{Writer} 템플릿을 정의함으로서 일반화된 방식으로 함수의 리턴값을 ``장식해(embellish)'' 볼 것이다.

\begin{snip}{cpp}
template<class A>
using Writer = pair<A, string>;
\end{snip}
그리고 이것이 장식된 함수다.

\begin{snip}{cpp}
Writer<string> toUpper(string s) {
    string result;
    int (*toupperp)(int) = &toupper;
    transform(begin(s), end(s), back_inserter(result), toupperp);
    return make_pair(result, "toUpper "); 
}

Writer<vector<string>> toWords(string s) { 
    return make_pair(words(s), "toWords ");
}
\end{snip}
이제 이 함수들을 합성한 또다른 장식된 함수를 만들어보자. 이 함수는 문자열의 소문자를 모두 대문자로 바꾸고, 이 문자열을 공백을 기준으로 분할한다. 그리고 그 과정에 대한 로그를 생성한다.
아마 아래와 같은 방식으로 구현할 수 있을 것이다.

\begin{snip}{cpp}
Writer<vector<string>> process(string s) {
    auto p1 = toUpper(s);
    auto p2 = toWords(p1.first);
    return make_pair(p2.first, p1.second + p2.second);
}
\end{snip}
이제 원래의 목표를 달성했다. 로그를 모으는 것은 더 이상 개별 함수의 관심사가 아니다. 각 함수는 메시지를 생성하고, 함수 외부에서 그 메시지를 연결해서 더 큰 로그를 만들어낸다.

이제 프로그램을 전부 이 방식으로 작성했다고 상상해보자. 이 프로그램은 반복되고, 에러에 취약한 코드로 가득찬 끔찍한 형태일 것이다. 하지만 우리는 프로그래머다.
이런 반복되는 코드를 어떻게 처리해야하는 지 알고 있다. 답은 바로 추상화다!
% mill abstraction이 무슨 의미일까요?? 찾아봐도 영.. 일단 대충 제가 받아들인 뜻에 맞춰서 번역했어요 %
하지만 이건 늘상하던 그런 추상화가 아니다.우리는 \newterm{함수\trComposition} 자체를 추상화할 것이다.
그러나 \trComposition은 \trCategoryTheory의 정수 그 자체이기 때문에, 코드를 짜기 전에 먼저 문제를 \trCategory의 시점에서 분석해보자.

\section{Writer \trCategory}

The idea of embellishing the return types of a bunch of functions in
order to piggyback some additional functionality turns out to be very
fruitful. We'll see many more examples of it. The starting point is our
regular category of types and functions. We'll leave the types as
objects, but redefine our morphisms to be the embellished functions.

For instance, suppose that we want to embellish the function
\code{isEven} that goes from \code{int} to \code{bool}. We turn it
into a morphism that is represented by an embellished function. The
important point is that this morphism is still considered an arrow
between the objects \code{int} and \code{bool}, even though the
embellished function returns a pair:

\begin{snip}{cpp}
pair<bool, string> isEven(int n) {
    return make_pair(n % 2 == 0, "isEven ");
}
\end{snip}
By the laws of a category, we should be able to compose this morphism
with another morphism that goes from the object \code{bool} to
whatever. In particular, we should be able to compose it with our
earlier \code{negate}:

\begin{snip}{cpp}
pair<bool, string> negate(bool b) {
    return make_pair(!b, "Not so! ");
}
\end{snip}
Obviously, we cannot compose these two morphisms the same way we compose
regular functions, because of the input/output mismatch. Their
composition should look more like this:

\begin{snip}{cpp}
pair<bool, string> isOdd(int n) {
    pair<bool, string> p1 = isEven(n);
    pair<bool, string> p2 = negate(p1.first);
    return make_pair(p2.first, p1.second + p2.second);
}
\end{snip}
So here's the recipe for the composition of two morphisms in this new
category we are constructing:

\begin{enumerate}
\tightlist
\item
  Execute the embellished function corresponding to the first morphism
\item
  Extract the first component of the result pair and pass it to the
  embellished function corresponding to the second morphism
\item
  Concatenate the second component (the string) of the first result
  and the second component (the string) of the second result
\item
  Return a new pair combining the first component of the final result
  with the concatenated string.
\end{enumerate}

If we want to abstract this composition as a higher order function in
C++, we have to use a template parameterized by three types
corresponding to three objects in our category. It should take two
embellished functions that are composable according to our rules, and
return a third embellished function:

\begin{snip}{cpp}
template<class A, class B, class C>
function<Writer<C>(A)> compose(function<Writer<B>(A)> m1,
                               function<Writer<C>(B)> m2)
{
    return [m1, m2](A x) {
        auto p1 = m1(x);
        auto p2 = m2(p1.first);
        return make_pair(p2.first, p1.second + p2.second); 
    };
}
\end{snip}
Now we can go back to our earlier example and implement the composition
of \code{toUpper} and \code{toWords} using this new template:

\begin{snip}{cpp}
Writer<vector<string>> process(string s) { 
    return compose<string, string, vector<string>>(toUpper, toWords)(s);
}
\end{snip}
There is still a lot of noise with the passing of types to the
\code{compose} template. This can be avoided as long as you have a
C++14-compliant compiler that supports generalized lambda functions with
return type deduction (credit for this code goes to Eric Niebler):

\begin{snip}{cpp}
auto const compose = [](auto m1, auto m2) { 
    return [m1, m2](auto x) { 
        auto p1 = m1(x);
        auto p2 = m2(p1.first);
        return make_pair(p2.first, p1.second + p2.second);
    };
};
\end{snip}
In this new definition, the implementation of \code{process}
simplifies to:

\begin{snip}{cpp}
Writer<vector<string>> process(string s) {
    return compose(toUpper, toWords)(s);
}
\end{snip}
But we are not finished yet. We have defined composition in our new
category, but what are the identity morphisms? These are not our regular
identity functions! They have to be morphisms from type A back to type
A, which means they are embellished functions of the form:

\begin{snip}{cpp}
Writer<A> identity(A);
\end{snip}
They have to behave like units with respect to composition. If you look
at our definition of composition, you'll see that an identity morphism
should pass its argument without change, and only contribute an empty
string to the log:

\begin{snip}{cpp}
template<class A> Writer<A> identity(A x) {
    return make_pair(x, "");
}
\end{snip}
You can easily convince yourself that the category we have just defined
is indeed a legitimate category. In particular, our composition is
trivially associative. If you follow what's happening with the first
component of each pair, it's just a regular function composition, which
is associative. The second components are being concatenated, and
concatenation is also associative.

An astute reader may notice that it would be easy to generalize this
construction to any monoid, not just the string monoid. We would use
\code{mappend} inside \code{compose} and \code{mempty} inside
\code{identity} (in place of \code{+} and \code{""}). There really
is no reason to limit ourselves to logging just strings. A good library
writer should be able to identify the bare minimum of constraints that
make the library work --- here the logging library's only requirement is
that the log have monoidal properties.

\section{Writer in Haskell}

The same thing in Haskell is a little more terse, and we also get a lot
more help from the compiler. Let's start by defining the \code{Writer}
type:

\src{snippet01}
Here I'm just defining a type alias, an equivalent of a \code{typedef}
(or \code{using}) in C++. The type \code{Writer} is parameterized by
a type variable \code{a} and is equivalent to a pair of \code{a} and
\code{String}. The syntax for pairs is minimal: just two items in
parentheses, separated by a comma.

Our morphisms are functions from an arbitrary type to some
\code{Writer} type:

\src{snippet02}
We'll declare the composition as a funny infix operator, sometimes
called the ``fish'':

\src{snippet03}
It's a function of two arguments, each being a function on its own, and
returning a function. The first argument is of the type
\code{(a -> Writer b)}, the second is
\code{(b -> Writer c)}, and the result is
\code{(a -> Writer c)}.

Here's the definition of this infix operator --- the two arguments
\code{m1} and \code{m2} appearing on either side of the fishy
symbol:

\src{snippet04}
The result is a lambda function of one argument \code{x}. The lambda
is written as a backslash --- think of it as the Greek letter λ with an
amputated leg.

The \code{let} expression lets you declare auxiliary variables. Here
the result of the call to \code{m1} is pattern matched to a pair of
variables \code{(y, s1)}; and the result of the call to \code{m2},
with the argument \code{y} from the first pattern, is matched to
\code{(z, s2)}.

It is common in Haskell to pattern match pairs, rather than use
accessors, as we did in C++. Other than that there is a pretty
straightforward correspondence between the two implementations.

The overall value of the \code{let} expression is specified in its
\code{in} clause: here it's a pair whose first component is \code{z}
and the second component is the concatenation of two strings,
\code{s1++s2}.

I will also define the identity morphism for our category, but for
reasons that will become clear much later, I will call it
\code{return}.

\src{snippet05}
For completeness, let's have the Haskell versions of the embellished
functions \code{upCase} and \code{toWords}:

\src{snippet06}
The function \code{map} corresponds to the C++ \code{transform}. It
applies the character function \code{toUpper} to the string
\code{s}. The auxiliary function \code{words} is defined in the
standard Prelude library.

Finally, the composition of the two functions is accomplished with the
help of the fish operator:

\src{snippet07}

\section{Kleisli Categories}

You might have guessed that I haven't invented this category on the
spot. It's an example of the so called Kleisli category --- a category
based on a monad. We are not ready to discuss monads yet, but I wanted
to give you a taste of what they can do. For our limited purposes, a
Kleisli category has, as objects, the types of the underlying
programming language. Morphisms from type $A$ to type $B$ are functions that
go from $A$ to a type derived from $B$ using the particular embellishment.
Each Kleisli category defines its own way of composing such morphisms,
as well as the identity morphisms with respect to that composition.
(Later we'll see that the imprecise term ``embellishment'' corresponds
to the notion of an endofunctor in a category.)

The particular monad that I used as the basis of the category in this
post is called the \newterm{writer monad} and it's used for logging or
tracing the execution of functions. It's also an example of a more
general mechanism for embedding effects in pure computations. You've
seen previously that we could model programming-language types and
functions in the category of sets (disregarding bottoms, as usual). Here
we have extended this model to a slightly different category, a category
where morphisms are represented by embellished functions, and their
composition does more than just pass the output of one function to the
input of another. We have one more degree of freedom to play with: the
composition itself. It turns out that this is exactly the degree of
freedom which makes it possible to give simple denotational semantics to
programs that in imperative languages are traditionally implemented
using side effects.

\section{Challenge}

A function that is not defined for all possible values of its argument
is called a partial function. It's not really a function in the
mathematical sense, so it doesn't fit the standard categorical mold. It
can, however, be represented by a function that returns an embellished
type \code{optional}:

\begin{snip}{cpp}
template<class A> class optional {
    bool _isValid;
    A _value;
public: 
    optional()    : _isValid(false) {}
    optional(A v) : _isValid(true), _value(v) {}
    bool isValid() const { return _isValid; }
    A value() const { return _value; }
};
\end{snip}
For example, here's the implementation of the embellished function
\code{safe\_root}:

\begin{snip}{cpp}
optional<double> safe_root(double x) {
    if (x >= 0) return optional<double>{sqrt(x)}; 
    else return optional<double>{};
}
\end{snip}
Here's the challenge:

\begin{enumerate}
\tightlist
\item
  Construct the Kleisli category for partial functions (define
  composition and identity).
\item
  Implement the embellished function \code{safe\_reciprocal} that
  returns a valid reciprocal of its argument, if it's different from
  zero.
\item
  Compose the functions \code{safe\_root} and \code{safe\_reciprocal} to implement
  \code{safe\_root\_reciprocal} that calculates \code{sqrt(1/x)}
  whenever possible.
\end{enumerate}