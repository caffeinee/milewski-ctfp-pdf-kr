% !TEX root = ../../ctfp-print.tex

함수와 타입 \trCategory\는  프로그래밍에서 중요한 역할을 담당한다. 그러니 타입이 무엇이고 언제 그것이 필요한지 얘기해보자.

\section{타입이 누구에게 필요한가?}

정적 타입 vs 동적 타입, 강 타입 vs 약 타입 각각의 이점에 관해 약간의 논란이 있는 것 같다.
각각의 선택을 사고 실험을 통해 표현해보자. 수백만 마리의 원숭이가 컴퓨터 키보드 앞에서 아무 키나 랜덤하게 누르고, 프로그램을 작성하고, 컴파일하고, 실행하고 있다.

\begin{figure}[H]
\centering
\includegraphics[width=0.3\textwidth]{images/img_1329.jpg}
\end{figure}

\noindent
기계어의 경우, 원숭이들이 만든 어떤 종류의 바이트열 조합도 허용되며 실행될 수 있다.
하지만 좀 더 고수준 언어의 경우, 컴파일러가 어휘적(lexical), 문법적 오류를 잡아낼 수 있다는 사실에 감사할 수 있을 것이다.
많은 원숭이들이 바나나 없이 떠나게 되겠지만, 남은 프로그램들은 유용해질 수 있는 좀 더 나은 기회를 갖게 될 것이다.
타입 검사는 무의미한 프로그램에 대한 또다른 방어책을 제공해준다.
더 나아가, 타입 불일치를 실행 중에만 감지할 수 있는 동적 타입 언어와 다르게 정적 타입 언어는 이를 컴파일 타임에 잡아낼 수 있게 해 준다.
실행하기 전에 수많은 잘못된 프로그램을 잡아낼 기회를 제공하는 것이다.

그래서 질문은 이거다. 우리는 원숭이를 행복하게 하기를 바라는 걸까, 아니면 올바른 프로그램을 만들어내길 원하는 걸까?

타이핑하는 원숭이 사고실험의 일반적인 목표는 셰익스피어 작품을 완벽하게 만들어내는 것이다.
이 반복에서 맞춤법 검사기와 문법 검사기를 갖게 되는 것은 성공 가능성을 엄청나게 증가시킨다.
타입 검사기와 비슷한 것이 있다면, 로미오가 사람으로 선언될 경우 그에게서 나뭇잎이 자라나거나, 그의 강력한 중력장이 광자(photon)를 붙잡아두게 된다거나 하지 못하게 만듦으로써 더욱 멀리까지 나아갈 수 있을 것이다.

\section{타입은 \trComposability에 관한 것}

\trCategoryTheory이란 곧 \trArrow\를 합성하는 것이다. 하지만 어느 두 \trArrow도 합성될 수 없다. 
한 \trArrow의 \trTargetObject\는 반드시 다음 \trArrow의 \trSourceObject\와 같아야만 한다.
프로그래밍에서 우리는 한 함수의 결과를 다른 함수로 전달할 수 있다.
만약 \trTargetFunction\이 \trSourceFunction에서 만든 데이터를 올바르게 해석할 수 없다면 프로그램은 동작하지 않을 것이다.
이 두 부분은 \trComposition\이 동작하기 위해 반드시 일치해야 한다.
언어의 타입 시스템이 강하면 강할 수록 이 두 가지가 일치하는지 여부를 더 잘 표현하고 기계적으로 판별 가능하게 된다.

강 타입에 대해 내가 들은 이야기 중 유일하게 일리가 있었던 주장은 강 타입이 의미론적으로는 올바른 몇몇 프로그램을 거부할 수 있다는 것이었다.
하지만 실제로 이런 일은 굉장히 드물게 일어나며, 어느 경우에서든 모든 언어들은 정말 필요할 경우 타입 시스템을 우회할 수 있도록 만들어주는 백도어를 제공한다.
심지어 하스켈 마저 \code{unsafeCoerce}를 제공한다. 하지만 이런 장치들은 반드시 사려깊게 사용되어야 한다.
프란츠 카프카의 소설 변신의 주인공 그레고르는 거대한 벌레로 변신하면서 타입 시스템을 부숴버렸고, 그 결과가 어땠는지는 모두들 잘 알고 있을 것이다.

흔히 듣는 또다른 주장은 타입을 다루는 일이 프로그래머에게 너무 큰 부담을 지운다는 것이었다. 
C++에서 반복자 선언을 몇 번 하고 나면 느낄 이런 감정적인 부분에 공감은 간다.
하지만, 사용된 문맥에 따라 컴파일러가 자동으로 대부분의 타입을 추정해내는 \newterm{\trTypeInference}으로 불리는 기술이 존재한다.
C++에서 \code{auto}를 이용해 변수를 선언하면 컴파일러가 자동으로 그 변수의 타입을 지정해줄 것이다.

하스켈에서는 아주 희귀한 몇몇 경우를 제외하고는 \trTypeAnnotation\은 선택사항에 불과하다.
하지만 그 사실과는 별개로 프로그래머들은 \trTypeAnnotation\을 사용하려고 하는 경향이 있다.
왜냐하면 타입 \trAnnotation\은 코드의 의미에 대해 굉장히 많은 것을 말해주고, 컴파일 에러를 더 쉽게 이해할 수 있게 만들어주기 때문이다.
하스켈에서 타입 설계로부터 프로젝트를 시작하는 것은 흔히 쓰이는 방법이다. 
\sloppy{이후에, \trTypeAnnotation은 구현을 이끌어 나가며, 컴파일러가 강제하는 코멘트가 된다.}

강한 정적 타입은 코드를 테스트하지 않는 것에 대한 변명거리로 자주 사용된다.
당신은 하스켈 프로그래머가 ``컴파일이 된다면, 그건 제대로 동작하는 프로그램일 것이다''라고 말하는 것을 몇 번 들은 적이 있을 지도 모른다.
물론, 타입이 올바르다고 해서 제대로된 동작을 할 것이라는 보장은 어디에도 없다.
이런 무신경한 태도는 여러 연구에서 예상과 달리 하스켈이 코드 퀄리티 측면에서 크게 앞서있지 않다는 결과로 나타난다.
It seems that, in the commercial setting, the pressure to
fix bugs is applied only up to a certain quality level, which has
everything to do with the economics of software development and the
tolerance of the end user, and very little to do with the programming
language or methodology. A better criterion would be to measure how many
projects fall behind schedule or are delivered with drastically reduced
functionality.

유닛 테스트가 강타입을 대체할 수 있다는 주장의 경우, "특정 함수가 받는 인자의 타입을 바꾸기"라는 강 타입 언어에서 흔한 리팩토링 과정을 생각해보자.
강 타입 언어의 경우 단순히 함수의 선언을 바꾸고 그 다음 일어나는 모든 빌드 에러들을 수정하는 것으로 충분하다.
반면 약 타입 언어에서는 타입을 바꿔도 그 함수를 호출할 때 해당 함수가 타입과 안 맞는 데이터가 전달되지 않을 것이라 가정한다는 사실만이 남는다.
유닛 테스트가 타입 불일치중 일부를 잡아줄지도 모르지만, 테스트는 항상 결정적이기보다는 확률적인 과정이다. 테스트는 증명의 형편없는 대체제일 뿐이다.

\section{타입이란 무엇인가?}

타입에 대한 가장 간단한 직관은 이것을 값의 집합으로 보는 것이다.
\code{Bool}이라는 타입(하스켈에서 타입은 대문자로 시작한다는 사실을 기억하자)은 \code{True}와 \code{False}라는 두 개의 값으로 이루어진 집합이다.
\code{Char}이라는 타입은 \code{a}나 \code{ą} 등의 유니코드 문자로 이루어진 집합이다.

집합은 유한할 수도 있고 무한할 수도 있다. \code{Char}의 리스트와 동의어인 \code{String} 타입을 무한 집합의 예시로 들 수 있다.

\code{x}를 \code{Integer} 타입으로 선언해보자.

\src{snippet01}
우리는 이제 이 값이 정수 집합의 한 원소라고 얘기할 수 있다.
하스켈에서 \code{Integer}는 무한 집합이며, 임의 크기의 산술 연산을 하는데 사용될 수 있다. \code{Int}라는 유한한 크기의 집합도 있는데 이는 C++의 \code{int}처럼 동작하는 기기에 부합하는 크기를 가진다.

타입과 집합에서 이런 방식의 구분을 까다롭게 만드는 구석이 있다.
재귀적인 정의를 포함하는 \trPolymorphic(polymorphic) 함수를 쓸 경우, 모든 집합에 대한 집합을 정의할 수 없다는 문제가 있는 것이다.
물론 앞서 예기했 듯 수학적으로 까다롭게 굴 생각은 없다. 중요한 것은 $\Set$이라고 불리는 집합의 \trCategory가 있으며, 우리는 이것을 다룰 것이라는 사실이다.
$\Set$에서, 모든 \trObject\는 집합이며 모든 \trMorphism(\trArrow)\은 함수이다.

$\Set$은 아주 특별한 \trCategory다. 왜냐하면 이 \trCategory의 \trObject 내부에 있는 것을 실제로 꺼내 볼 수 있고, 이로부터 많은 직관을 얻을 수 있기 때문이다.
예를 들어, 우리는 공집합은 어떤 원소도 포함하지 않는다는 것을 안다. 우리는 원소가 하나밖에 없는 특별한 집합이 있다는 것을 알고, 어떤 집합의 원소를 다른 집합의 원소와 대응시키는 함수가 있다는 것을 안다.
이 함수는 서로 다른 두 원소를 어느 한 원소에 대응시킬 순 있지만, 하나의 원소를 두 원소에 대응시킬 수는 없다.
우리는 어떤 집합의 원소를 그 원소 자신과 대응시키는 항등 함수가 있다는 사실 등도 알고 있다.
목표는 이 모든 지식을 천천히 잃어버리고, 대신에 순수하게 \trCategory의 용어, 그러니까 \trObject와 \trArrow로 표현하게 되는 것이다.

이상적으로는 하스켈의 타입은 집합이고 하스켈의 함수는 집합 사이의 수학적 함수라고 이야기할 수 있다.
하지만 한가지 작은 문제가 있다. 수학에서의 함수는 어떤 코드도 실행시키지 않고, 단지 그 실행 결과를 알고 있을 뿐이다.
하스켈의 함수는 답을 계산해야 한다. 만약 답이 유한한 단계 안에 유도될 수 있는 경우라면 이것은 별로 문제가 되지 않는다(물론 단계 수가 많다면 좀 문제가 될 지도 모른다).
하지만 재귀를 포함하는 연산들도 있고 이 연산들은 어쩌면 종료되지 않을 수도 있다. 이런 종료되지 않는 함수를 하스켈에서 아예 제외하는 것은 불가능하다.
어떤 함수가 종료되는지 아닌지 여부를 판단하는 문제는 정지 문제라는 이름으로 널리 알려진 결정 불가능한 문제이기 때문이다.
이를 해결하기 위해 컴퓨터 과학자들은 한가지 놀라운 아이디어, 혹은 관점에 따라 중요한 핵(hack)으로 불리는 특별한 값인 \newterm{\trBottom}을 제안하게 됐다.
이 값은 모든 타입에 포함되며, \code{\_|\_} 혹은 유니코드 $\bot$으로 적는다. 이 ``값''은 종료되지 않는 연산에 대응된다. 따라서, 함수는 아래와 같이 선언될 수 있다.

\src{snippet02}
이 함수는 True, False, 혹은 \code{\_|\_}를 리턴할 수 있다. 맨 마지막 타입은 이 함수가 종료되지 않을 수도 있음을 뜻한다.

흥미롭게도, \trBottom을 타입 시스템의 일부로 받아들이고 나면, 모든 런타임 에러를 \trBottom으로 대하는 것은 아주 편리하게 느껴진다. 이는 \code{undefined} \trExpression을 사용하면 아래 코드와 같이 쉽게 작성할 수 있다.

\src{snippet03}

이 함수의 타입 정의는 \code{undefined}가 \trBottom으로 평가되고, 이 값이 \code{Bool}을 포함한 임의의 타입에 속하기 때문에 적법한 코드다. 심지어, 이렇게도 쓸 수 있다.

\src{snippet04}

(\code{x}가 제거됐다) 왜냐하면, \trBottom 은 \code{Bool -> Bool} 타입에도 속할 수 있기 때문이다.

\trBottom을 리턴할 수 있는 함수는 \trPartial(partial) 함수라고 불린다. 반대로, 가능한 모든 \trArgument에 대해 올바른 결과값을 내놓는 함수는 \trTotal(total) 함수라고 불린다.

\trBottom으로 인해, 하스켈의 타입과 함수의 \trCategory는 $\Set$ 보다는 $\Hask$로 지칭된다.
이론적인 측면에서 이것은 끝없는 복잡함의 원천이기 때문에 지금은 이와 관련된 이야기는 적당히 넘기려고 한다. 실용적인 측면에서 종료되지 않는 함수와 \trBottom을 무시하고 $\Hask$를 진짜 $\Set$으로 생각해도 무방하다.
\footnote{Nils Anders Danielsson,
John Hughes, Patrik Jansson, Jeremy Gibbons, \href{http://www.cs.ox.ac.uk/jeremy.gibbons/publications/fast+loose.pdf}{
Fast and Loose Reasoning is Morally Correct}. 이 논문이 대부분의 맥락에서 \trBottom을 무시하는 것에 대한 타당한 이유를 제시해준다.}

\section{왜 수학적 모델이 필요한가?}

프로그래머로서 당신은 사용하는 프로그래밍 언어의 문법과 구문에 굉장히 익숙할 것이다.
언어의 이런 측면들은 보통 언어 스펙의 제일 첫 부분에 formal notation을 이용해서 기술되곤 한다. % formal notation을 뭐라고 번역하는게 좋을까요?
하지만, 언어의 \trSemantics(semantics)적인 측면은 기술하기가 좀 더 까다롭다. 이는 훨씬 많은 페이지를 필요로 하며, 충분히 형식적이지 못하며, 대부분의 경우 절대 완벽해지지 못한다.
Hence the never ending discussions among language
lawyers, and a whole cottage industry of books dedicated to the exegesis
of the finer points of language standards.

% 이쪽 전반적으로 용어 번역이 어렵네요.. 좋은 의견 있으면 말씀해주세요 ㅠㅠ 프로그래밍 언어 관련 단어들의 한국어 번역을 잘 모르겠군요
언어의 \trSematnics적인 측면을 기술하는 형식화된 도구들이 존재하지만, 그 복잡성 때문에 주로 단순화된 학술 언어에서만 사용되며 실세계의 거대한 프로그래밍 언어에서는 사용되지 않는다.
그런 도구들 중 하나인 \newterm{\trOperationalSemantics}\는 프로그램 실행 메커니즘을 기술한다. 이 도구는 형식화된 이상적인 인터프리터를 정의한다.
C++과 같은 산업적인 언어들의 \trSemantics는 보통 ``추상 기계(abstract machine)''과 같은 형식적이지 못한 연산 추론(operational reasoning)을 이용해서 기술한다.

문제는 \trOperationalSemantics를 이용해서 프로그램에 관한 증명을 하는 것이 굉장히 어렵다는 점이다. 프로그램의 특성을 보이려면 반드시 이상적인 인터프리터를 통해 프로그램을 ``실행''해 보아야만 한다.

프로그래머들이 정당성에 관한 형식적 증명을 절대 수행하지 않는다는 점은 문제가 아니다. 우리는 항상 우리가 올바른 프로그램을 작성하고 있는지에 관해 ``생각''한다.
누구도 키보드 앞에 앉아서 ``음, 적당히 코드 몇 줄 쳐넣은 다음에 무슨 일이 일어나는지 확인해봐야지.''라고 이야기하지는 않는다.
우리는 우리가 작성한 코드가 원하는 결과를 이끌어내는 일련의 동작을 할 것이라고 생각한다. 작성한 코드가 예상과 다르게 동작하면 보통 우리는 크게 놀라게 된다.
이말인 즉, 우리는 우리가 짠 프로그램의 동작에 대해 추론하며, 종종 프로그램을 머릿속의 인터프리터를 이용해 실행해본다는 뜻이다.
모든 변수값들을 추적해나가는 것은 굉장히 힘든 일이고, 컴퓨터는 프로그램을 수행하는데 특화되어있지만 사람은 그렇지 않다.
우리가 이런 일을 잘 해낼 수 있었다면 컴퓨터가 필요하지 않았을 것이다.

하지만 여기엔 대체제가 있다. 이것은 \newTerm{\trDenotationalSemantics}라고 불린다. 이 도구는 수학에 기반한다.
\trDenotationalSemantics에서 모든 프로그래밍적 구성은 그것의 수학적 해석(interpretation)으로 주어진다.
이것을 이용하면, 프로그램의 특성을 증명하고 싶을 때 단순히 수학적 정리(theorem)를 증명하면 된다.
이런 수학적 증명이 어렵다고 생각할지도 모르지만, 인간은 수천년동안 수학적인 방법들을 만들어왔고

But there is an alternative. It's called \newterm{denotational semantics}
and it's based on math. In denotational semantics every programming
construct is given its mathematical interpretation. With that, if you
want to prove a property of a program, you just prove a mathematical
theorem. You might think that theorem proving is hard, but the fact is
that we humans have been building up mathematical methods for thousands
of years, so there is a wealth of accumulated knowledge to tap into.
Also, as compared to the kind of theorems that professional
mathematicians prove, the problems that we encounter in programming are
usually quite simple, if not trivial.

Consider the definition of a factorial function in Haskell, which is a
language quite amenable to denotational semantics:

\src{snippet05}
The expression \code{{[}1..n{]}} is a list of integers from \code{1} to \code{n}.
The function \code{product} multiplies all elements of a list. That's
just like a definition of factorial taken from a math text. Compare this
with C:

\begin{snip}{c}
int fact(int n) {
    int i;
    int result = 1;
    for (i = 2; i <= n; ++i)
        result *= i;
    return result;
}
\end{snip}
Need I say more?

Okay, I'll be the first to admit that this was a cheap shot! A factorial
function has an obvious mathematical denotation. An astute reader might
ask: What's the mathematical model for reading a character from the
keyboard or sending a packet across the network? For the longest time
that would have been an awkward question leading to a rather convoluted
explanation. It seemed like denotational semantics wasn't the best fit
for a considerable number of important tasks that were essential for
writing useful programs, and which could be easily tackled by
operational semantics. The breakthrough came from category theory.
Eugenio Moggi discovered that computational effect can be mapped to
monads. This turned out to be an important observation that not only
gave denotational semantics a new lease on life and made pure functional
programs more usable, but also shed new light on traditional
programming. I'll talk about monads later, when we develop more
categorical tools.

One of the important advantages of having a mathematical model for
programming is that it's possible to perform formal proofs of
correctness of software. This might not seem so important when you're
writing consumer software, but there are areas of programming where the
price of failure may be exorbitant, or where human life is at stake. But
even when writing web applications for the health system, you may
appreciate the thought that functions and algorithms from the Haskell
standard library come with proofs of correctness.

\section{Pure and Dirty Functions}

The things we call functions in C++ or any other imperative language,
are not the same things mathematicians call functions. A mathematical
function is just a mapping of values to values.

We can implement a mathematical function in a programming language: Such
a function, given an input value will calculate the output value. A
function to produce a square of a number will probably multiply the
input value by itself. It will do it every time it's called, and it's
guaranteed to produce the same output every time it's called with the
same input. The square of a number doesn't change with the phases of the
Moon.

Also, calculating the square of a number should not have a side effect
of dispensing a tasty treat for your dog. A ``function'' that does that
cannot be easily modelled as a mathematical function.

In programming languages, functions that always produce the same result
given the same input and have no side effects are called \newterm{pure
functions}. In a pure functional language like Haskell all functions are
pure. Because of that, it's easier to give these languages denotational
semantics and model them using category theory. As for other languages,
it's always possible to restrict yourself to a pure subset, or reason
about side effects separately. Later we'll see how monads let us model
all kinds of effects using only pure functions. So we really don't lose
anything by restricting ourselves to mathematical functions.

\section{Examples of Types}

Once you realize that types are sets, you can think of some rather
exotic types. For instance, what's the type corresponding to an empty
set? No, it's not C++ \code{void}, although this type \emph{is} called
\code{Void} in Haskell. It's a type that's not inhabited by any
values. You can define a function that takes \code{Void}, but you can
never call it. To call it, you would have to provide a value of the type
\code{Void}, and there just aren't any. As for what this function can
return, there are no restrictions whatsoever. It can return any type
(although it never will, because it can't be called). In other words
it's a function that's polymorphic in the return type. Haskellers have a
name for it:

\src{snippet06}
(Remember, \code{a} is a type variable that can stand for any type.)
The name is not coincidental. There is deeper interpretation of types
and functions in terms of logic called the Curry-Howard isomorphism. The
type \code{Void} represents falsity, and the type of the function
\code{absurd} corresponds to the statement that from falsity follows
anything, as in the Latin adage ``ex falso sequitur quodlibet.''

Next is the type that corresponds to a singleton set. It's a type that
has only one possible value. This value just ``is.'' You might not
immediately recognize it as such, but that is the C++ \code{void}.
Think of functions from and to this type. A function from \code{void}
can always be called. If it's a pure function, it will always return the
same result. Here's an example of such a function:

\begin{snip}{c}
int f44() { return 44; }
\end{snip}
You might think of this function as taking ``nothing'', but as we've
just seen, a function that takes ``nothing'' can never be called because
there is no value representing ``nothing.'' So what does this function
take? Conceptually, it takes a dummy value of which there is only one
instance ever, so we don't have to mention it explicitly. In Haskell,
however, there is a symbol for this value: an empty pair of parentheses,
\code{()}. So, by a funny coincidence (or is it a coincidence?), the
call to a function of void looks the same in C++ and in Haskell. Also,
because of the Haskell's love of terseness, the same symbol \code{()}
is used for the type, the constructor, and the only value corresponding
to a singleton set. So here's this function in Haskell:

\src{snippet07}
The first line declares that \code{f44} takes the type \code{()},
pronounced ``unit,'' into the type \code{Integer}. The second line
defines \code{f44} by pattern matching the only constructor for unit,
namely \code{()}, and producing the number 44. You call this function
by providing the unit value \code{()}:

\begin{snip}{c}
f44 ()
\end{snip}
Notice that every function of unit is equivalent to picking a single
element from the target type (here, picking the \code{Integer} 44). In
fact you could think of \code{f44} as a different representation for
the number 44. This is an example of how we can replace explicit mention
of elements of a set by talking about functions (arrows) instead.
Functions from unit to any type $A$ are in one-to-one correspondence with
the elements of that set $A$.

What about functions with the \code{void} return type, or, in Haskell,
with the unit return type? In C++ such functions are used for side
effects, but we know that these are not real functions in the
mathematical sense of the word. A pure function that returns unit does
nothing: it discards its argument.

Mathematically, a function from a set $A$ to a singleton set maps every
element of $A$ to the single element of that singleton set. For every $A$
there is exactly one such function. Here's this function for
\code{Integer}:

\src{snippet08}
You give it any integer, and it gives you back a unit. In the spirit of
terseness, Haskell lets you use the wildcard pattern, the underscore,
for an argument that is discarded. This way you don't have to invent a
name for it. So the above can be rewritten as:

\src{snippet09}
Notice that the implementation of this function not only doesn't depend
on the value passed to it, but it doesn't even depend on the type of the
argument.

Functions that can be implemented with the same formula for any type are
called parametrically polymorphic. You can implement a whole family of
such functions with one equation using a type parameter instead of a
concrete type. What should we call a polymorphic function from any type
to unit type? Of course we'll call it \code{unit}:

\src{snippet10}
In C++ you would write this function as:

\begin{snip}{cpp}
template<class T>
void unit(T) {}
\end{snip}
Next in the typology of types is a two-element set. In C++ it's called
\code{bool} and in Haskell, predictably, \code{Bool}. The difference
is that in C++ \code{bool} is a built-in type, whereas in Haskell it
can be defined as follows:

\src{snippet11}
(The way to read this definition is that \code{Bool} is either
\code{True} or \code{False}.) In principle, one should also be able
to define a Boolean type in C++ as an enumeration:

\begin{snip}{cpp}
enum bool { 
    true,
    false
};
\end{snip}
but C++ \code{enum} is secretly an integer. The C++11
``\code{enum class}'' could have been used instead, but then you
would have to qualify its values with the class name, as in
\code{bool::true} and \code{bool::false}, not to mention having to
include the appropriate header in every file that uses it.

Pure functions from \code{Bool} just pick two values from the target
type, one corresponding to \code{True} and another to \code{False}.

Functions to \code{Bool} are called \newterm{predicates}. For instance,
the Haskell library \code{Data.Char} is full of predicates like
\code{isAlpha} or \code{isDigit}. In C++ there is a similar library
\code{} that defines, among others, \code{isalpha} and
\code{isdigit}, but these return an \code{int} rather than a
Boolean. The actual predicates are defined in \code{std::ctype} and
have the form \code{ctype::is(alpha, c)}, \code{ctype::is(digit, c)}, etc.

\section{Challenges}

\begin{enumerate}
\tightlist
\item
  Define a higher-order function (or a function object) \code{memoize}
  in your favorite language. This function takes a pure function
  \code{f} as an argument and returns a function that behaves almost
  exactly like \code{f}, except that it only calls the original
  function once for every argument, stores the result internally, and
  subsequently returns this stored result every time it's called with
  the same argument. You can tell the memoized function from the
  original by watching its performance. For instance, try to memoize a
  function that takes a long time to evaluate. You'll have to wait for
  the result the first time you call it, but on subsequent calls, with
  the same argument, you should get the result immediately.
\item
  Try to memoize a function from your standard library that you normally
  use to produce random numbers. Does it work?
\item
  Most random number generators can be initialized with a seed.
  Implement a function that takes a seed, calls the random number
  generator with that seed, and returns the result. Memoize that
  function. Does it work?
\item
  Which of these C++ functions are pure? Try to memoize them and observe
  what happens when you call them multiple times: memoized and not.

  \begin{enumerate}
  \tightlist
  \item
    The factorial function from the example in the text.
  \item
\begin{minted}{cpp}
std::getchar()
\end{minted}
  \item
\begin{minted}{cpp}
bool f() { 
    std::cout << "Hello!" << std::endl;
    return true;
}
\end{minted}
  \item
\begin{minted}{cpp}
int f(int x) {
    static int y = 0;
    y += x;
    return y;
}
\end{minted}
  \end{enumerate}
\item
  How many different functions are there from \code{Bool} to
  \code{Bool}? Can you implement them all?
\item
  Draw a picture of a category whose only objects are the types
  \code{Void}, \code{()} (unit), and \code{Bool}; with arrows
  corresponding to all possible functions between these types. Label the
  arrows with the names of the functions.
\end{enumerate}