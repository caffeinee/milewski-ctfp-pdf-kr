% !TEX root = ../../ctfp-print.tex

\lettrine[lhang=0.17]{함}{수}와 타입 \trCategory\는  프로그래밍에서 중요한 역할을 담당한다. 그러니 타입이 무엇이고 언제 그것이 필요한지 얘기해보자.

\section{타입이 누구에게 필요한가?}

정적 타입 vs 동적 타입, 강 타입 vs 약 타입 각각의 이점에 관해 약간의 논란이 있는 것 같다.
각각의 선택을 사고 실험을 통해 표현해보자. 수백만 마리의 원숭이가 컴퓨터 키보드 앞에서 아무 키나 랜덤하게 누르고, 프로그램을 작성하고, 컴파일하고, 실행하고 있다.

\begin{figure}[H]
\centering
\includegraphics[width=0.3\textwidth]{images/img_1329.jpg}
\end{figure}

\noindent
기계어의 경우, 원숭이들이 만든 어떤 종류의 바이트열 조합도 허용되며 실행될 수 있다.
하지만 좀 더 고수준 언어의 경우, 컴파일러가 어휘적(lexical), 문법적 오류를 잡아낼 수 있다는 사실에 감사할 수 있을 것이다.
많은 원숭이들이 바나나 없이 떠나게 되겠지만, 남은 프로그램들은 유용해질 수 있는 좀 더 나은 기회를 갖게 될 것이다.
타입 검사는 무의미한 프로그램에 대한 또다른 방어책을 제공해준다.
더 나아가, 타입 불일치를 실행 중에만 감지할 수 있는 동적 타입 언어와 다르게 정적 타입 언어는 이를 컴파일 타임에 잡아낼 수 있게 해 준다.
실행하기 전에 수많은 잘못된 프로그램을 잡아낼 기회를 제공하는 것이다.

그래서 질문은 이거다. 우리는 원숭이를 행복하게 하기를 바라는 걸까, 아니면 올바른 프로그램을 만들어내길 원하는 걸까?

타이핑하는 원숭이 사고실험의 일반적인 목표는 셰익스피어 작품을 완벽하게 만들어내는 것이다.
이 반복에서 맞춤법 검사기와 문법 검사기를 갖게 되는 것은 성공 가능성을 엄청나게 증가시킨다.
타입 검사기와 비슷한 것이 있다면, 로미오가 사람으로 선언될 경우 그에게서 나뭇잎이 자라나거나, 그의 강력한 중력장이 광자(photon)를 붙잡아두게 된다거나 하지 못하게 만듦으로써 더욱 멀리까지 나아갈 수 있을 것이다.

\section{타입은 \trComposability에 관한 것}

\trCategoryTheory이란 곧 \trArrow\를 합성하는 것이다. 하지만 어느 두 \trArrow도 합성될 수 없다. 
한 \trArrow의 \trTargetObject\는 반드시 다음 \trArrow의 \trSourceObject\와 같아야만 한다.
프로그래밍에서 우리는 한 함수의 결과를 다른 함수로 전달할 수 있다.
만약 \trTargetFunction\이 \trSourceFunction에서 만든 데이터를 올바르게 해석할 수 없다면 프로그램은 동작하지 않을 것이다.
이 두 부분은 \trComposition\이 동작하기 위해 반드시 일치해야 한다.
언어의 타입 시스템이 강하면 강할 수록 이 두 가지가 일치하는지 여부를 더 잘 표현하고 기계적으로 판별 가능하게 된다.

강 타입에 대해 내가 들은 이야기 중 유일하게 일리가 있었던 주장은 강 타입이 의미론적으로는 올바른 몇몇 프로그램을 거부할 수 있다는 것이었다.
하지만 실제로 이런 일은 굉장히 드물게 일어나며, 어느 경우에서든 모든 언어들은 정말 필요할 경우 타입 시스템을 우회할 수 있도록 만들어주는 백도어를 제공한다.
심지어 하스켈 마저 \code{unsafeCoerce}를 제공한다. 하지만 이런 장치들은 반드시 사려깊게 사용되어야 한다.
프란츠 카프카의 소설 변신의 주인공 그레고르는 거대한 벌레로 변신하면서 타입 시스템을 부숴버렸고, 그 결과가 어땠는지는 모두들 잘 알고 있을 것이다.

흔히 듣는 또다른 주장은 타입을 다루는 일이 프로그래머에게 너무 큰 부담을 지운다는 것이었다. 
C++에서 반복자 선언을 몇 번 하고 나면 느낄 이런 감정적인 부분에 공감은 간다.
하지만, 사용된 문맥에 따라 컴파일러가 자동으로 대부분의 타입을 추정해내는 \newterm{\trTypeInference}으로 불리는 기술이 존재한다.
C++에서 \code{auto}를 이용해 변수를 선언하면 컴파일러가 자동으로 그 변수의 타입을 지정해줄 것이다.

하스켈에서는 아주 희귀한 몇몇 경우를 제외하고는 \trTypeAnnotation\은 선택사항에 불과하다.
하지만 그 사실과는 별개로 프로그래머들은 \trTypeAnnotation\을 사용하려고 하는 경향이 있다.
왜냐하면 \trTypeAnnotation\은 코드의 의미에 대해 굉장히 많은 것을 말해주고, 컴파일 에러를 더 쉽게 이해할 수 있게 만들어주기 때문이다.
하스켈에서 타입 설계로부터 프로젝트를 시작하는 것은 흔히 쓰이는 방법이다. 
\sloppy{이후에, \trTypeAnnotation은 구현을 이끌어 나가며, 컴파일러가 강제하는 코멘트가 된다.}

강한 정적 타입은 코드를 테스트하지 않는 것에 대한 변명거리로 자주 사용된다.
당신은 하스켈 프로그래머가 ``컴파일이 된다면, 그건 제대로 동작하는 프로그램일 것이다''라고 말하는 것을 몇 번 들은 적이 있을 지도 모른다.
물론, 타입이 올바르다고 해서 제대로된 동작을 할 것이라는 보장은 어디에도 없다.
이런 무신경한 태도는 여러 연구에서 예상과 달리 하스켈이 코드 퀄리티 측면에서 크게 앞서있지 않다는 결과로 나타난다.
It seems that, in the commercial setting, the pressure to
fix bugs is applied only up to a certain quality level, which has
everything to do with the economics of software development and the
tolerance of the end user, and very little to do with the programming
language or methodology. A better criterion would be to measure how many
projects fall behind schedule or are delivered with drastically reduced
functionality.

유닛 테스트가 강타입을 대체할 수 있다는 주장의 경우, "특정 함수가 받는 인자의 타입을 바꾸기"라는 강 타입 언어에서 흔한 리팩토링 과정을 생각해보자.
강 타입 언어의 경우 단순히 함수의 선언을 바꾸고 그 다음 일어나는 모든 빌드 에러들을 수정하는 것으로 충분하다.
반면 약 타입 언어에서는 타입을 바꿔도 그 함수를 호출할 때 해당 함수가 타입과 안 맞는 데이터가 전달되지 않을 것이라 가정한다는 사실만이 남는다.
유닛 테스트가 타입 불일치중 일부를 잡아줄지도 모르지만, 테스트는 항상 결정적이기보다는 확률적인 과정이다. 테스트는 증명의 형편없는 대체제일 뿐이다.

\section{타입이란 무엇인가?}

타입에 대한 가장 간단한 직관은 이것을 값의 집합으로 보는 것이다.
\code{Bool}이라는 타입(하스켈에서 타입은 대문자로 시작한다는 사실을 기억하자)은 \code{True}와 \code{False}라는 두 개의 값으로 이루어진 집합이다.
\code{Char}이라는 타입은 \code{a}나 \code{ą} 등의 유니코드 문자로 이루어진 집합이다.

집합은 유한할 수도 있고 무한할 수도 있다. \code{Char}의 리스트와 동의어인 \code{String} 타입을 무한 집합의 예시로 들 수 있다.

\code{x}를 \code{Integer} 타입으로 선언해보자.

\src{snippet01}
우리는 이제 이 값이 정수 집합의 한 원소라고 얘기할 수 있다.
하스켈에서 \code{Integer}는 무한 집합이며, 임의 크기의 산술 연산을 하는데 사용될 수 있다. \code{Int}라는 유한한 크기의 집합도 있는데 이는 C++의 \code{int}처럼 동작하는 기기에 부합하는 크기를 가진다.

타입과 집합에서 이런 방식의 구분을 까다롭게 만드는 구석이 있다.
재귀적인 정의를 포함하는 \trPolymorphic(polymorphic) 함수를 쓸 경우, 모든 집합에 대한 집합을 정의할 수 없다는 문제가 있는 것이다.
물론 앞서 예기했 듯 수학적으로 까다롭게 굴 생각은 없다. 중요한 것은 $\Set$이라고 불리는 집합의 \trCategory가 있으며, 우리는 이것을 다룰 것이라는 사실이다.
$\Set$에서, 모든 \trObject\는 집합이며 모든 \trMorphism(\trArrow)\은 함수이다.

$\Set$은 아주 특별한 \trCategory다. 왜냐하면 이 \trCategory의 \trObject 내부에 있는 것을 실제로 꺼내 볼 수 있고, 이로부터 많은 직관을 얻을 수 있기 때문이다.
예를 들어, 우리는 공집합은 어떤 원소도 포함하지 않는다는 것을 안다. 우리는 원소가 하나밖에 없는 특별한 집합이 있다는 것을 알고, 어떤 집합의 원소를 다른 집합의 원소와 대응시키는 함수가 있다는 것을 안다.
이 함수는 서로 다른 두 원소를 어느 한 원소에 대응시킬 순 있지만, 하나의 원소를 두 원소에 대응시킬 수는 없다.
우리는 어떤 집합의 원소를 그 원소 자신과 대응시키는 항등 함수가 있다는 사실 등도 알고 있다.
목표는 이 모든 지식을 천천히 잃어버리고, 대신에 순수하게 \trCategory의 용어, 그러니까 \trObject와 \trArrow로 표현하게 되는 것이다.

이상적으로는 하스켈의 타입은 집합이고 하스켈의 함수는 집합 사이의 수학적 함수라고 이야기할 수 있다.
하지만 한가지 작은 문제가 있다. 수학에서의 함수는 어떤 코드도 실행시키지 않고, 단지 그 실행 결과를 알고 있을 뿐이다.
하스켈의 함수는 답을 계산해야 한다. 만약 답이 유한한 단계 안에 유도될 수 있는 경우라면 이것은 별로 문제가 되지 않는다(물론 단계 수가 많다면 좀 문제가 될 지도 모른다).
하지만 재귀를 포함하는 연산들도 있고 이 연산들은 어쩌면 종료되지 않을 수도 있다. 이런 종료되지 않는 함수를 하스켈에서 아예 제외하는 것은 불가능하다.
어떤 함수가 종료되는지 아닌지 여부를 판단하는 문제는 정지 문제라는 이름으로 널리 알려진 결정 불가능한 문제이기 때문이다.
이를 해결하기 위해 컴퓨터 과학자들은 한가지 놀라운 아이디어, 혹은 관점에 따라 중요한 핵(hack)으로 불리는 특별한 값인 \newterm{\trBottom}을 제안하게 됐다.
이 값은 모든 타입에 포함되며, \code{\_|\_} 혹은 유니코드 $\bot$으로 적는다. 이 ``값''은 종료되지 않는 연산에 대응된다. 따라서, 함수는 아래와 같이 선언될 수 있다.

\src{snippet02}
이 함수는 True, False, 혹은 \code{\_|\_}를 리턴할 수 있다. 맨 마지막 타입은 이 함수가 종료되지 않을 수도 있음을 뜻한다.

흥미롭게도, \trBottom을 타입 시스템의 일부로 받아들이고 나면, 모든 런타임 에러를 \trBottom으로 대하는 것은 아주 편리하게 느껴진다. 이는 \code{undefined} \trExpression을 사용하면 아래 코드와 같이 쉽게 작성할 수 있다.

\src{snippet03}

이 함수의 타입 정의는 \code{undefined}가 \trBottom으로 평가되고, 이 값이 \code{Bool}을 포함한 임의의 타입에 속하기 때문에 적법한 코드다. 심지어, 이렇게도 쓸 수 있다.

\src{snippet04}

(\code{x}가 제거됐다) 왜냐하면, \trBottom 은 \code{Bool -> Bool} 타입에도 속할 수 있기 때문이다.

\trBottom을 리턴할 수 있는 함수는 \trPartial(partial) 함수라고 불린다. 반대로, 가능한 모든 \trArgument에 대해 올바른 결과값을 내놓는 함수는 \trTotal(total) 함수라고 불린다.

\trBottom으로 인해, 하스켈의 타입과 함수의 \trCategory는 $\Set$ 보다는 $\Hask$로 지칭된다.
이론적인 측면에서 이것은 끝없는 복잡함의 원천이기 때문에 지금은 이와 관련된 이야기는 적당히 넘기려고 한다. 실용적인 측면에서 종료되지 않는 함수와 \trBottom을 무시하고 $\Hask$를 진짜 $\Set$으로 생각해도 무방하다.
\footnote{Nils Anders Danielsson,
John Hughes, Patrik Jansson, Jeremy Gibbons, \href{http://www.cs.ox.ac.uk/jeremy.gibbons/publications/fast+loose.pdf}{
Fast and Loose Reasoning is Morally Correct}. 이 논문이 대부분의 맥락에서 \trBottom을 무시하는 것에 대한 타당한 이유를 제시해준다.}

\section{왜 수학적 모델이 필요한가?}

프로그래머로서 당신은 사용하는 프로그래밍 언어의 문법과 구문에 굉장히 익숙할 것이다.
언어의 이런 측면들은 보통 언어 스펙의 제일 첫 부분에 formal notation을 이용해서 기술되곤 한다. % formal notation을 뭐라고 번역하는게 좋을까요?
하지만, 언어의 \trSemantics(semantics)적인 측면은 기술하기가 좀 더 까다롭다. 이는 훨씬 많은 페이지를 필요로 하며, 충분히 형식적이지 못하며, 대부분의 경우 절대 완벽해지지 못한다.
Hence the never ending discussions among language
lawyers, and a whole cottage industry of books dedicated to the exegesis
of the finer points of language standards.

% 이쪽 전반적으로 용어 번역이 어렵네요.. 좋은 의견 있으면 말씀해주세요 ㅠㅠ 프로그래밍 언어 관련 단어들의 한국어 번역을 잘 모르겠군요
언어의 \trSematnics적인 측면을 기술하는 형식화된 도구들이 존재하지만, 그 복잡성 때문에 주로 단순화된 학술 언어에서만 사용되며 실세계의 거대한 프로그래밍 언어에서는 사용되지 않는다.
그런 도구들 중 하나인 \newterm{\trOperationalSemantics}(operational semantics)\는 프로그램 실행 메커니즘을 기술한다. 이 도구는 형식화된 이상적인 인터프리터를 정의한다.
C++과 같은 산업적인 언어들의 \trSemantics는 보통 ``추상 기계(abstract machine)''과 같은 형식적이지 못한 연산 추론(operational reasoning)을 이용해서 기술한다.

문제는 \trOperationalSemantics를 이용해서 프로그램에 관한 증명을 하는 것이 굉장히 어렵다는 점이다. 프로그램의 특성을 보이려면 반드시 이상적인 인터프리터를 통해 프로그램을 ``실행''해 보아야만 한다.

프로그래머들이 정당성에 관한 형식적 증명을 절대 수행하지 않는다는 점은 문제가 아니다. 우리는 항상 우리가 올바른 프로그램을 작성하고 있는지에 관해 ``생각''한다.
누구도 키보드 앞에 앉아서 ``음, 적당히 코드 몇 줄 쳐넣은 다음에 무슨 일이 일어나는지 확인해봐야지.''라고 이야기하지는 않는다.
우리는 우리가 작성한 코드가 원하는 결과를 이끌어내는 일련의 동작을 할 것이라고 생각한다. 작성한 코드가 예상과 다르게 동작하면 보통 우리는 크게 놀라게 된다.
이말인 즉, 우리는 우리가 짠 프로그램의 동작에 대해 추론하며, 종종 프로그램을 머릿속의 인터프리터를 이용해 실행해본다는 뜻이다.
모든 변수값들을 추적해나가는 것은 굉장히 힘든 일이고, 컴퓨터는 프로그램을 수행하는데 특화되어있지만 사람은 그렇지 않다.
우리가 이런 일을 잘 해낼 수 있었다면 컴퓨터가 필요하지 않았을 것이다.

하지만 여기엔 대체제가 있다. 이것은 \newTerm{\trDenotationalSemantics}(denotational semantics)라고 불린다. 이 도구는 수학에 기반한다.
\trDenotationalSemantics에서 모든 프로그래밍적 구성은 그것의 수학적 해석(interpretation)으로 주어진다.
이것을 이용하면, 프로그램의 특성을 증명하고 싶을 때 단순히 수학적 정리(theorem)를 증명하면 된다.
이런 수학적 증명이 어렵다고 생각할지도 모르지만, 인간은 수천년동안 수학적 기술을 발전시켜왔고 따라서 이 지식들의 혜택을 많이 받을 수 있다.
또, 수학자들이 증명하는 부류의 정리들과 비교해서 우리가 프로그래밍하며 만나는 문제들은 대부분의 경우 전형적인 수준까진 아니다 하더라도 아주 단순한 범주에 속한다.

\trDenotationalSemantics에서 아주 잘 처리할 수 있는 언어인 하스켈에서의 팩토리얼 함수 정의를 생각해보자. 

\src{snippet05}

\trExpression \code{{[}1..n{]}} 는 \code{1} 부터 \code{n}까지의 정수 \trList이다.  \code{product} 함수는 \trList에 속한 모든 원소를 곱해준다. 이건 수학에서의 팩토리얼 정의와 굉장히 유사하다. C언어와 비교해보자.

\begin{snip}{c}
int fact(int n) {
    int i;
    int result = 1;
    for (i = 2; i <= n; ++i)
        result *= i;
    return result;
}
\end{snip}

더 설명이 필요할까?

그래, 이런 비교를 드는게 비열한 짓이라는 걸 인정하겠다. 팩토리얼은 명확한 수학적 표기를 가지고 있는 함수다. 약삭빠른 독자라면 이렇게 물어볼 것이다.
키보드로부터 문자를 읽어들이거나, 네트워크를 통해 패킷을 보내는 것에 대한 수학적 모델은 뭡니까? 이 질문은 오랫동안 상당히 난해한 설명을 요구하는 까다로운 질문이었다.
\trDenotationalSemantics\는 유용한 프로그램을 작성하기 위해 필수적이고 중요한 수많은 작업들에 적합하지 않아 보이고, 반면 \trOperationalSemantics\는 이런 걸 쉽게 다룰 수 있다.
% computational effect 를 뭐라고 번역하는게 좋을까요?
돌파구는 \trCategoryTheory에서 나왔다. 유제니오 모지(Eugenio Moggi)는 계산의 영향(computational effect)을 \trMonad에 대응시킬 수 있다는 것을 발견했다.
이것은 \trDenotationalSemantics의 목숨을 연장시켜주고 순수 함수형 언어를 더 유용하게 만들어주었을 뿐 아니라, 전통적인 방식의 프로그래밍에도 한줄기 빛이 되었다는 것이 밝혀졌다.
\trMonad에 대해서는 이후에 \trCategory스러운 도구들을 좀 더 다루고 난 후 이야기하겠다.

프로그래밍을 위한 수학적 도구를 가지게 되는 것의 가장 중요한 이점은 소프트웨어의 정당성에 대해 형식적 증명을 수행할 수 있게 된다는 것이다.
이건 일반적인 소비자용 소프트웨어를 작성할 때는 별로 중요해보이지 않지만, 세상에는 실패에 대한 비용이 말도 안되게 크거나, 사람의 목숨이 걸려 있는 영역도 존재한다.
혹은 의료체계에 관한 웹 어플리케이션을 작성할 때에도 haskell의 표준 라이브러리에 있는 알고리즘과 함수가 정당성에 대한 증명을 수반한다는 것에 감사하게 될 것이다.

\section{순수한(pure) 함수와 더러운(dirty) 함수}

C++ 혹은 다른 명령형 언어에서 우리가 지칭하는 함수는 수학에서 지칭하는 함수와 다르다. 수학에서의 함수는 단순히 값과 값 사이의 사상(mapping)이다.

수학적 함수를 프로그래밍 언어로 구현하는 것도 가능하다. 이런 함수에서는, 주어진 입력값으로 출력값을 계산하게 된다.
어떤 숫자의 제곱을 계산하는 함수는, 입력으로 하나의 숫자를 받은 뒤 그 숫자를 자기자신에게 곱한 값을 돌려줄 것이다.
이런 함수는 같은 입력이 주어질 경우 호출할 때마다 항상 같은 출력이 나온다는 것이 보장된다.
주어진 수의 제곱을 계산하는 게 달의 위상을 바꿀 수는 없다.

또, 수의 제곱을 계산하는 것은 키우는 개에게 맛있는 식사를 제공하는 \trSideEffect를 일으킬 수도 없다. 이런 효과를 일으키는 ``함수''는 수학적 함수로 쉽게 표현되지 못한다.

프로그래밍 언어에서, 같은 입력에 대해 항상 같은 출력을 내놓으며 어떤 \trSideeffect도 가지지 않는 함수를 \newterm{순수 함수}라고 부른다.
하스켈과 같은 순수한 함수형 언어에서는 모든 함수가 순수하다. 때문에, 이런 언어들에 \trDenotationalSemantics를 부여하고 \trCategoryTheory\를 사용해 모델링할 수 있다.
다른 언어들의 경우, 언어 기능 중 순수한 부분 집합만 사용하거나 \trSideEffect에 대해서 별개로 생각하게끔 스스로를 강제하는건 항상 가능하다.
이후에 \trMonad가 모든 종류의 효과(effect)를 어떻게 순수한 함수만 가지고 모델링할 수 있게 해주는지 살펴볼 것이다.
그래서 수학적 함수만 사용하도록 제약한다 해도 우리는 잃게 되는게 아무것도 없다.

\section{타입의 예시}

타입이 곧 집합이라는 것을 깨닫고 나면, 좀 더 특이한 종류의 타입에 대해서도 생각해 볼 수 있게 된다.
예를 들어, 공집합에 대응되는 타입은 무엇일까? 아니, 이 타입이 하스켈에서 \code{Void}로 불리긴 하지만, C++의 \code{void}는 공집합이 아니다. 
하스켈의 \code{Void} 타입에 속하는 값은 존재하지 않는다. \code{Void} 타입을 받는 함수를 정의할 수는 있지만, 이 함수는 절대 호출할 수가 없다.
이 함수를 호출하기 위해선 \code{Void} 타입의 값을 제공해야 하지만 이 타입에 속하는 값은 존재하지 않기 때문이다. 
이 함수가 리턴하는 값은 그게 무엇이 됐든 아무런 제약도 존재하지 않는다. 이 함수는 아무 타입의 값이나 리턴할 수 있다(하지만, 호출될 수가 없으니 실제로는 일어날 일이 없을 것이다).
다르게 표현하자면, 이 함수는 \trPolymorphic 리턴 타입을 가진 함수이다. 하스켈에는 이 함수를 위한 이름이 있다.


\src{snippet06}
(\code{a}가 임의의 타입을 나타내는 타입 변수라는 사실을 기억하자.)
이 이름은 우연의 일치가 아니다. 커리-하워드 \trIsomorphism(Curry-Howard Isomorphism)\이라고 불리는, 논리학적 측면에서 함수와 타입에 대한 깊은 이해의 산물이 있다.
% 이거 번역 어떻게 하죠 ㅠㅠ ex falso sequitur quodlibet가 애매한데 %
\code{Void} 타입은 거짓을 나타내고, 따라서 \code{absurd} 함수의 타입은, 라틴 격언 ``ex falso sequitur quodlibet''과 마찬 가지로 거짓 가정 뒤에는 임의의 문장이 뒤따를 수 있음을 나타낸다.

다음은 단일 원소를 가진 집합에 대응되는 타입이다. 이 타입은 단 하나의 값만 가질 수 있다.

Next is the type that corresponds to a singleton set. It's a type that
has only one possible value. This value just ``is.'' You might not
immediately recognize it as such, but that is the C++ \code{void}.
Think of functions from and to this type. A function from \code{void}
can always be called. If it's a pure function, it will always return the
same result. Here's an example of such a function:

\begin{snip}{c}
int f44() { return 44; }
\end{snip}
You might think of this function as taking ``nothing'', but as we've
just seen, a function that takes ``nothing'' can never be called because
there is no value representing ``nothing.'' So what does this function
take? Conceptually, it takes a dummy value of which there is only one
instance ever, so we don't have to mention it explicitly. In Haskell,
however, there is a symbol for this value: an empty pair of parentheses,
\code{()}. So, by a funny coincidence (or is it a coincidence?), the
call to a function of void looks the same in C++ and in Haskell. Also,
because of the Haskell's love of terseness, the same symbol \code{()}
is used for the type, the constructor, and the only value corresponding
to a singleton set. So here's this function in Haskell:

\src{snippet07}
The first line declares that \code{f44} takes the type \code{()},
pronounced ``unit,'' into the type \code{Integer}. The second line
defines \code{f44} by pattern matching the only constructor for unit,
namely \code{()}, and producing the number 44. You call this function
by providing the unit value \code{()}:

\begin{snip}{c}
f44 ()
\end{snip}
Notice that every function of unit is equivalent to picking a single
element from the target type (here, picking the \code{Integer} 44). In
fact you could think of \code{f44} as a different representation for
the number 44. This is an example of how we can replace explicit mention
of elements of a set by talking about functions (arrows) instead.
Functions from unit to any type $A$ are in one-to-one correspondence with
the elements of that set $A$.

What about functions with the \code{void} return type, or, in Haskell,
with the unit return type? In C++ such functions are used for side
effects, but we know that these are not real functions in the
mathematical sense of the word. A pure function that returns unit does
nothing: it discards its argument.

Mathematically, a function from a set $A$ to a singleton set maps every
element of $A$ to the single element of that singleton set. For every $A$
there is exactly one such function. Here's this function for
\code{Integer}:

\src{snippet08}
You give it any integer, and it gives you back a unit. In the spirit of
terseness, Haskell lets you use the wildcard pattern, the underscore,
for an argument that is discarded. This way you don't have to invent a
name for it. So the above can be rewritten as:

\src{snippet09}
Notice that the implementation of this function not only doesn't depend
on the value passed to it, but it doesn't even depend on the type of the
argument.

Functions that can be implemented with the same formula for any type are
called parametrically polymorphic. You can implement a whole family of
such functions with one equation using a type parameter instead of a
concrete type. What should we call a polymorphic function from any type
to unit type? Of course we'll call it \code{unit}:

\src{snippet10}
In C++ you would write this function as:

\begin{snip}{cpp}
template<class T>
void unit(T) {}
\end{snip}
Next in the typology of types is a two-element set. In C++ it's called
\code{bool} and in Haskell, predictably, \code{Bool}. The difference
is that in C++ \code{bool} is a built-in type, whereas in Haskell it
can be defined as follows:

\src{snippet11}
(The way to read this definition is that \code{Bool} is either
\code{True} or \code{False}.) In principle, one should also be able
to define a Boolean type in C++ as an enumeration:

\begin{snip}{cpp}
enum bool { 
    true,
    false
};
\end{snip}
but C++ \code{enum} is secretly an integer. The C++11
``\code{enum class}'' could have been used instead, but then you
would have to qualify its values with the class name, as in
\code{bool::true} and \code{bool::false}, not to mention having to
include the appropriate header in every file that uses it.

Pure functions from \code{Bool} just pick two values from the target
type, one corresponding to \code{True} and another to \code{False}.

Functions to \code{Bool} are called \newterm{predicates}. For instance,
the Haskell library \code{Data.Char} is full of predicates like
\code{isAlpha} or \code{isDigit}. In C++ there is a similar library
\code{} that defines, among others, \code{isalpha} and
\code{isdigit}, but these return an \code{int} rather than a
Boolean. The actual predicates are defined in \code{std::ctype} and
have the form \code{ctype::is(alpha, c)}, \code{ctype::is(digit, c)}, etc.

\section{Challenges}

\begin{enumerate}
\tightlist
\item
  Define a higher-order function (or a function object) \code{memoize}
  in your favorite language. This function takes a pure function
  \code{f} as an argument and returns a function that behaves almost
  exactly like \code{f}, except that it only calls the original
  function once for every argument, stores the result internally, and
  subsequently returns this stored result every time it's called with
  the same argument. You can tell the memoized function from the
  original by watching its performance. For instance, try to memoize a
  function that takes a long time to evaluate. You'll have to wait for
  the result the first time you call it, but on subsequent calls, with
  the same argument, you should get the result immediately.
\item
  Try to memoize a function from your standard library that you normally
  use to produce random numbers. Does it work?
\item
  Most random number generators can be initialized with a seed.
  Implement a function that takes a seed, calls the random number
  generator with that seed, and returns the result. Memoize that
  function. Does it work?
\item
  Which of these C++ functions are pure? Try to memoize them and observe
  what happens when you call them multiple times: memoized and not.

  \begin{enumerate}
  \tightlist
  \item
    The factorial function from the example in the text.
  \item
\begin{minted}{cpp}
std::getchar()
\end{minted}
  \item
\begin{minted}{cpp}
bool f() { 
    std::cout << "Hello!" << std::endl;
    return true;
}
\end{minted}
  \item
\begin{minted}{cpp}
int f(int x) {
    static int y = 0;
    y += x;
    return y;
}
\end{minted}
  \end{enumerate}
\item
  How many different functions are there from \code{Bool} to
  \code{Bool}? Can you implement them all?
\item
  Draw a picture of a category whose only objects are the types
  \code{Void}, \code{()} (unit), and \code{Bool}; with arrows
  corresponding to all possible functions between these types. Label the
  arrows with the names of the functions.
\end{enumerate}